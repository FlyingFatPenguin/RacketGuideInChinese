9.8 回溯

我们已经明白贪婪的量词匹配的次数最多，但压倒一切的优先级才是整体匹配的成功。考虑以下内容

> (regexp-match #rx"a*a" "aaaa")

'("aaaa")

这个正则表达式包括两个子正则表达式：a*，其次是a。子正则表达式a*不允许匹配文本字符串aaaa内的所有的四个a，即使*是一个贪婪量词也一样。它可能仅匹配前面的三个，剩下最后一个给第二子正则表达式。这确保了完整的正则表达式匹配成功。

正则表达式匹配器通过一个称为回溯（backtracking）的过程实现来这个。匹配器暂时允许贪婪量词匹配所有四个a，但当整体匹配处于岌岌可危的状态变得清晰时，它回溯（backtracks）到一个不那么贪婪的三个a的匹配。如果这也失败了，与以下调用一样

> (regexp-match #rx"a*aa" "aaaa")

'("aaaa")

匹配器回溯甚至更进一步。只有当所有可能的回溯尝试都没有成功时，整体失败才被承认。

回溯并不局限于贪婪量词。非贪婪量词匹配尽可能少的情况下，为了达到整体匹配，逐步回溯会有越来越多的实例。这里替代的回溯也更有向右替代的倾向，当局部成功的向左替代一旦失败则会产生一个整体的匹配。

有时禁用回溯是有效的。例如，我们可能希望作出选择，或者我们知道尝试替代是徒劳的。一个非回溯正则表达式在(?>...)里是封闭的。

> (regexp-match #rx"(?>a+)." "aaaa")

#f

在这个调用里，子正则表达式?>a+贪婪地匹配所有四个a，并且回溯的机会被拒绝。因此，整体匹配被拒绝。这个正则表达式的效果因此对一个或多个a的匹配被某些明确无a（non-a）的予以继承。
