本指南适用于新的Racket程序员或部分新的Racket程序员。本指南假定你是有编程经验的。如果您是新学习编程，那么请阅读《如何设计程序》（How to Design Programs）这部分。如果你想特别快地了解Racket语言，从这里开始：《 Quick: An Introduction to Racket with Pictures》这部分。

第2章简要介绍Racket语言。从第3章开始，本指南深入讨论了大部分的Racket语言工具箱，但把更清晰的细节内容留给Racket语言参考手册和其他参考手册介绍。

1 Racket语言欢迎你
  1.1 与Racket语言交互
  1.2 定义和交互
  1.3 创建可执行文件
  1.4 给有LISP/Scheme经验的读者的一个说明

2 Racket语言概要
  2.1 简单值
  2.2 简单的定义与表达式
  2.2.1 定义
  2.2.2 代码缩进
  2.2.3 标识符
  2.2.4 函数调用(应用程序)
  2.2.5 条件表达式if、and、or和cond
  2.2.6 函数反复调用
  2.2.7 匿名函数与lambda
  2.2.8 用define、let和let*实现本地绑定
  2.3 列表、迭代和递归
  2.3.1 预定义列表循环
  2.3.2 从头开始列表迭代
  2.3.3 尾递归
  2.3.4 递归和迭代
  2.4 pair、list和Racket的语法
  2.4.1 用quote引用pair和symbol
  2.4.2 使用引用的缩写（'）
  2.4.3 列表和Racket的语法

3 内置的数据类型
  3.1 布尔值（Boolean）
  3.2 数值（Number）
  3.3 字符（Character）
  3.4 字符串（Unicode Strings）
  3.5 字节（Byte）和字节字符串（Byte String）
  3.6 符号（Symbol）
  3.7 关键词（Keyword）
  3.8 对（Pair）和列表（List）
  3.9 向量（Vector）
  3.10 哈希表（Hash Table）
  3.11 盒（Box）
  3.12 无效值（Void）和未定义值（Undefined）

4 表达式和定义
  4.1 符号
  4.2 标识符和绑定
  4.3 函数调用（过程程序）
    4.3.1 赋值顺序和数量
    4.3.2 关键字参数
    4.3.3 apply函数
  4.4 lambda函数（程序）
    4.4.1 申明剩余（rest）参数
    4.4.2 声明可选（optional）参数
    4.4.3 声明关键字（keyword）参数
    4.4.4 多解函数：case-lambda
  4.5 定义：define
    4.5.1 函数速记法
    4.5.2 特殊功能速记法
    4.5.3 多值和define-values
    4.5.4 内部定义
  4.6 本地绑定
    4.6.1 并行绑定：let
    4.6.2 顺序绑定：let*
    4.6.3 递归绑定：letrec
    4.6.4 命名let
    4.6.5 多值绑定：let-values，let*-values，letrec-values
  4.7 条件分支
    4.7.1 简单分支：if
    4.7.2 组合测试：and和or
    4.7.3 约束测试：cond
  4.8 排序
    4.8.1 前置效应：gegin
    4.8.2 后置效应：begin0
    4.8.3 条件效应：when和unless
  4.9 赋值：set!
    4.9.1 使用的指导原则
    4.9.2 多值赋值：set!-values
  4.10 引用：quote和'
  4.11 类引用：quasiquote和`
  4.12 简单调度：case
  4.13 动态绑定：parameterize

5 自定义的数据类型
  5.1 简单的结构：struct
  5.2 复制和更新
  5.3 结构子类
  5.4 不透明结构与透明结构
  5.5 结构的比较
  5.6 结构的延展
  5.7 预制结构
  5.8 更多的结构选项

6 模块
  6.1 模块基础知识
    6.1.1 组织模块
    6.1.2 库集合
    6.1.3 包和集合
    6.1.4 添加集合
  6.2 模块的语法
    6.2.1 module表
    6.2.2 #lang速记法
    6.2.3 子模块
    6.2.4 主要的和测试的子模块
  6.3 模块的路径
  6.4 输入：require
  6.5 输出：provide
  6.6 赋值和重定义

7 合约
  7.1 合约和边界
    7.1.1合约的违反
    7.1.2 合约与模块的测试
    7.1.3 嵌套合约的测试
  7.2 函数的简单合约
    7.2.1 ->类型
    7.2.2 define/contract和->的使用
    7.2.3 and和any/c
    7.2.4 运转自己的合约
    7.2.5 合约的高阶函数
    7.2.6 ”???“的合约信息
    7.2.7 解析合约的错误消息
  7.3个合约的通用函数
    7.3.1 可选参数
    7.3.2 剩余参数
    7.3.3 关键字参数
    7.3.4 可选关键字参数
    7.3.5 case-lambda合约
    7.3.6 参数和结果的依赖
    7.3.7 检查状态的变化
    7.3.8 多个结果值
    7.3.9 固定但静态未知数量的参数
  7.4合约：一个全面的例子
  7.5 结构的合约
    7.5.1 对特定值的确保
    7.5.2 对所有值的确保
    7.5.3 数据结构的检查特性
  7.6 用#:exists和#:∃抽象合约
  7.7 额外的例子
    7.7.1 客户管理器的组成
    7.7.2 参数（简单）栈
    7.7.3 字典
    7.7.4 队列
  7.8 建立新合约
    7.8.1 合约结构属性
    7.8.2 所有的警告和报警
  7.9 陷阱
    7.9.1 合约和eq?
    7.9.2 合同的边界和define/contract
    7.9.3 合约的生存期和判定
    7.9.4 定义递归合合约
    7.9.5 混合set!和合约

8 输入和输出
  8.1 端口的种类
  8.2 默认端口
  8.3 读和写Racket数据
  8.4 数据类型和序列化
  8.5 字节、字符和编码
  8.6 输入/输出模式

9 正则表达式
  9.1 写regexp模式
  9.2 匹配正则表达式模式
  9.3 基本申明
  9.4 字符和字符类
    9.4.1 常用的字符类
    9.4.2 POSIX字符类
  9.5 量词
  9.6 集群
    9.6.1 反向引用
    9.6.2 非捕获集群
    9.6.3 回绕
  9.7 交替
  9.8 回溯
  9.9 向前看和后面看
    9.9.1 前瞻
    9.9.2 追溯
  9.10 一个扩展示例

10 例外与控制
10.1例外
10.2提示和中止


10.3的延续


11次迭代和理解


11.1序列构造函数


11.2和*


11.3为/列表和* /列表


11.4矢量/矢量


11.5为/或和/或


11.6个/第一个和最后一个


11.7折叠/折叠


11.8重值序列


11.9打破迭代


11.10迭代性能


12模式匹配


13类和对象


13.1方法


13.2初始化参数


13.3内部和外部名称


13.4接口


13.5最后，增强，和内部


13.6控制外部名称的范围


13.7混合


13.7.1混入和接口


13.7.2的混合形式


13.7.3 Parameterized Mixins


13.8性状


13.8.1特征集的混合


13.8.2继承超性状


13.8.3特质的形成


13.9类合同


13.9.1外部类合同


13.9.2内部类合同


14单位（部件）


14.1签名和单位


14.2调用单元


14.3连接单元


14.4等一级单位


14.5整个模块签名和单元


14.6单位合同


14.6.1加入合同签名


14.6.2加入合同单位


14.7单元vs模块


15反思与动态评价


15.1评价


15.1.1局部范围


15.1.2命名空间


15.1.3命名空间、模块


15.2操纵的命名空间


15.2.1创建和安装空间


15.2.2共享数据和代码的命名空间


15.3脚本评估和使用负载


16宏


16.1个基于模式的宏


16.1.1定义语法规则


16.1.2词法范围


16.1.3定义的语法和句法规则


16.1.4匹配序列


16.1.5标识符宏


16.1.6集！变压器


16.1.7宏生成宏


16.1.8扩展的例子：通过参考函数调用


16.2大通用变压器


16.2.1语法对象


16.2.2宏变压器程序


16.2.3混合模式及表达情况：语法


16.2.4语法生成临时对象


16.2.5编译和运行时间阶段


16.2.6相水平一般


16.2.6.1相绑定


16.2.6.2阶段和模块


16.2.7语法玷污


17创造语言


17.1模块语言


17.1.1隐式绑定


17.1.2使用#郎s-exp


17.2读者的扩展


17.2.1源位置


17.2.2 readtables


17.3定义新的#郎语言


17.3.1指定# lang Language


17.3.2使用#朗读者


17.3.3使用#郎s-exp语法/模块的读者


本安装语言


17.3.5源处理配置


17.3.6模块处理配置


18并发和同步


18.1螺纹


18.2螺纹的邮箱


18.3信号量


18.4通道


18.5个缓冲异步通道


18.6同步事件和同步


19性能


19.1性能在DrRacket


19.2字节码和即时（JIT）编译器


19.3模块与性能


19.4功能调用优化


19.5突变与性能


19.6 letrec性能


19.7 fixnum和Flonum Optimizations


19.8不检、不安全操作
    
