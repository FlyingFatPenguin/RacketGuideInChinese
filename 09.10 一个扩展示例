9.10 一个扩展示例

这是一个从《Friedl’s Mastering Regular Expressions》（189页）来的扩展的例子，涵盖了本章中介绍的许多特征。问题是要修饰一个正则表达式，它将匹配任何且唯一的IP地址或点缀四周：四个数字被三个点分开，每个数字在0和255之间。

首先，我们定义了一个子正则表达式n0-255以匹配0到255：

> (define n0-255
    (string-append
     "(?:"
     "\\d|"        ;   0 到   9
     "\\d\\d|"     ;  00 到  99
     "[01]\\d\\d|" ; 000 到 199
     "2[0-4]\\d|"  ; 200 到 249
     "25[0-5]"     ; 250 到 255
     ")"))

前两个替代只得到所有的一位数和两位数。因为0-padding是允许的，我们要匹配1和01。我们当得到3位数字时要小心，因为数字255以上必须排除。因此，我们的修饰替代，得到000至199，然后200至249，最后250至255。

IP地址是一个字符串，包括四个n0-255用三个点分隔。

> (define ip-re1
    (string-append
     "^"        ; 前面什么都没有
     n0-255     ; 第一个n0-255,
     "(?:"      ; 接着是子模式
     "\\."      ; 一个点跟着
     n0-255     ; 一个n0-255,
     ")"        ; 
     "{3}"      ; 恰好重复三遍
     "$"))
;后边什么也没有

让我们试试看：

> (regexp-match (pregexp ip-re1) "1.2.3.4")

'("1.2.3.4")
> (regexp-match (pregexp ip-re1) "55.155.255.265")

#f

这很好，除此之外我们还有

> (regexp-match (pregexp ip-re1) "0.00.000.00")

'("0.00.000.00")

所有的零序列都不是有效的IP地址！用向前查找救援。在开始匹配ip-re1之前，我们向前查找以确保我们没有零。我们可以用正向前查找去确保有非零的数字。

> (define ip-re
    (pregexp
     (string-append
       "(?=.*[1-9])" ; 确保这里是一个非0数
       ip-re1)))

或者我们可以用负前查找确保前面不是只由零和点组成。

> (define ip-re
    (pregexp
     (string-append
       "(?![0.]*$)" ; 不仅是0和点
                    ; (注意: .在[...]里面不是匹配器)
       ip-re1)))

正则表达式ip-re会匹配所有的并且唯一的IP地址。

> (regexp-match ip-re "1.2.3.4")

'("1.2.3.4")
> (regexp-match ip-re "0.0.0.0")

#f
