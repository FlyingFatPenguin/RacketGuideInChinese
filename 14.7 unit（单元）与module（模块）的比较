14.7 unit（单元）与module（模块）的比较

作为模块的一个表，unit是对module的补充：

1、module表主要用于管理通用命名空间。例如，它允许一个代码片段是专指来自racket/base的car运算——其中一个提取内置配对数据类型的一个实例的第一个元素——而不是任何其它带car名字的函数。换句话说，module构造允许你引用你想要的绑定。

2、unit表是参数化的代码片段相对于大多数运行时的值的任意种类。例如，它允许一个代码片段与一个接受单个参数的car函数一起工作，其中特定函数在稍后通过将片段连接到另一个参数被确定。换句话说，unit结构允许你引用满足某些规范的一个绑定。

除其他外，lambda和class表还允许对稍后选择的值进行代码参数化。原则上，其中任何一项都可以以其他任何方式执行。在实践中，每个表都提供了某些便利——例如允许重写方法或者特别是对值的特别简单的应用——使它们适合不同的目的。

从某种意义上说，module表比其它表更为基础。毕竟，没有module提供的命名空间管理，程序片段不能可靠地引用lambda、class或unit表。同时，由于名称空间管理与单独的扩展和编译密切相关，module边界以独立的编译边界结束，在某种程度上阻止了片段之间的相互依赖关系。出于类似的原因，module不将接口与实现分开。

使用unit的情况为，在module本身几乎可以运行时，但当独立编译的部分必须相互引用时，或当你想要在接口（interface）（即，需要在扩展和编译时间被知道的部分）和实现（implementation）（即，运行时部分）之间有一个更强健的隔离时。更普遍使用unit的情况是，当你需要在函数、数据类型和类上参数化代码时，以及当参数代码本身提供定义以和其它参数代码链接时。
